<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>shell教程 | DDUP</title><meta name="author" content="sunk"><meta name="copyright" content="sunk"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="摘自 一、什么是shell？shell是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言。 Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。 为什么要学习和使用shell？Shell属于内置的脚本，程序开发的效率非常高，依赖于功能强大的命令可以迅速地完成开发任务（批处理）语法简单，代码">
<meta property="og:type" content="article">
<meta property="og:title" content="shell教程">
<meta property="og:url" content="http://sunk15.top/2023/02/07/linux/shell%E6%95%99%E7%A8%8B/index.html">
<meta property="og:site_name" content="DDUP">
<meta property="og:description" content="摘自 一、什么是shell？shell是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言。 Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。 为什么要学习和使用shell？Shell属于内置的脚本，程序开发的效率非常高，依赖于功能强大的命令可以迅速地完成开发任务（批处理）语法简单，代码">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s1.ax1x.com/2023/02/08/pSRUin0.jpg">
<meta property="article:published_time" content="2023-02-07T02:12:20.000Z">
<meta property="article:modified_time" content="2023-02-21T01:42:08.908Z">
<meta property="article:author" content="sunk">
<meta property="article:tag" content="LINUX">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s1.ax1x.com/2023/02/08/pSRUin0.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://sunk15.top/2023/02/07/linux/shell%E6%95%99%E7%A8%8B/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'shell教程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-02-21 09:42:08'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s1.ax1x.com/2023/02/08/pS2XoY6.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">18</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://s1.ax1x.com/2023/02/08/pSRUin0.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="DDUP"><span class="site-name">DDUP</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">shell教程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-02-07T02:12:20.000Z" title="发表于 2023-02-07 10:12:20">2023-02-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-02-21T01:42:08.908Z" title="更新于 2023-02-21 09:42:08">2023-02-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/linux/">linux</a></span></div><div class="meta-secondline"></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/w918589859/article/details/108752592">摘自</a></p>
<h2 id="一、什么是shell？"><a href="#一、什么是shell？" class="headerlink" title="一、什么是shell？"></a>一、什么是shell？</h2><p>shell是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言。</p>
<p>Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。</p>
<p>为什么要学习和使用shell？<br>Shell属于内置的脚本，程序开发的效率非常高，依赖于功能强大的命令可以迅速地完成开发任务（批处理）语法简单，代码写起来比较轻松，简单易学</p>
<h2 id="二、shell的分类"><a href="#二、shell的分类" class="headerlink" title="二、shell的分类"></a>二、shell的分类</h2><pre><code>cat /etc/shells
</code></pre>
<p>在linux中有很多类型的shell，不同的shell具备不同的功能，shell还决定了脚本中函数的语法，Linux中默认的shell是&#x2F; b a s h &#x2F; b a s h （ 重 点 ），流行的shell有ash、bash、ksh、csh、zsh等，不同的shell都有自己的特点以及用途。</p>
<p>编写规范:</p>
<pre><code>#!/bin/bash				[指定告知系统当前这个脚本要使用的shell解释器]
Shell相关指令
</code></pre>
<p>文件命名规范：</p>
<pre><code>文件名.sh     .sh是linux下bash shell 的默认后缀
</code></pre>
<p>Bash 常用快捷键</p>
<pre><code>快捷键	作用
ctrl+A	把光标移动到命令行开头。如果我们输入的命令过长，想要把光标移动到命令行开头时使用。
ctrl+E	把光标移动到命令行结尾。
ctrl+C	强制终止当前的命令。
ctrl+L	清屏，相当于clear命令。
ctrl+U	删除或剪切光标之前的命令。我输入了一行很长的命令，不用使用退格键一个一个字符的删除，使用这个快捷键会更加方便
ctrl+K	删除或剪切光标之后的内容。
ctrl+Y	粘贴ctrl+U或ctul+K剪切的内容。
ctrl+R	在历史命令中搜索，按下ctrl+R之后，就会出现搜索界面，只要输入搜索内容，就会从历史命令中搜索。
ctrl+D	退出当前终端。
ctrl+Z	暂停，并放入后台。这个快捷键牵扯工作管理的内容，我们在系统管理章节详细介绍。
ctrl+S	暂停屏幕输出。
ctrl+Q	恢复屏幕输出。
</code></pre>
<p>输入输出重定向<br>linux 的标准输入与输出</p>
<pre><code>设备	设备名	    文件描述符	类型
键盘	/dev/stdin	0	标准输入
显示器	/dev/stdout	1	标准输出
显示器	/dev/stderr	2	标准错误输出
</code></pre>
<p>输入重定向</p>
<p>输入重定向：是指不使用系统提供的标准输入端口，而进行重新的指定。换言之，输入重定向就是不使用标准输入端口输入文件，而是使用指定的文件作为标准输入设备。（重定向简单理解就是使用 “&lt;”符来修改标准输入设备）</p>
<pre><code>类型	     符号（语法）   功能
标准输入        命令&lt;文件1      命令把文件1的内容作为标准输入设备
标识符限定输入      命令&lt;&lt;标识符        命令把标准输入中读入内容，直到遇到“标识符”分解符为止
输入输出重定向（同时使用）       命令&lt; 文件1 &gt;文件2	 命令把文件1的内容作为标准输入，把文件2作为标准输出。
</code></pre>
<p>输出重定向<br>输出重定向：（通俗的讲，重定向输出就是把要输出的文件信息写入到一个文件中去，而不是将要输出的文件信息输出到控制台（显示屏），在linux中，默认的标准输出设备是控制台（或称为显示器）,用户输出的信息默认情况下都会显示到控制台。</p>
<p>&amp;表示全部文件，文件不管对错，1表示标准输出文件，2表示标准错误输出。</p>
<pre><code>类型	符号	作用
标住输出重定向	命令 &gt; 文件	以覆盖方式，把命令的正确输出内容输出到指定的文件或设备当中
标住输出重定向	命令 &gt;&gt; 文件	以追加方式，把命令的正确输出内容输出到指定的文件或设备当中
标准错误输出重定向	错误命令2 &gt; 文件	以覆盖方式，把命令的错误输出输出到指定的文件或设备当中
标准错误输出重定向	错误命令2 &gt;&gt; 文件	以追加方式，把命令的错误输出输出到指定的文件或设备当中
正确输出和错误输出同时保存	命令 &gt; 文件 2&gt;&amp;1	以覆盖的方式，把正确输出和错误输出都保存到同一个文件当中。
正确输出和错误输出同时保存	命令 &gt;&gt; 文件 2&gt;&amp;1	以追加的方式，把正确输出和错误输出都保存到同一个文件当中。
正确输出和错误输出同时保存	命令 &amp;&gt; 文件	以覆盖的方式，把正确输出和错误输出都保存到同一个文件当中。
正确输出和错误输出同时保存	命令 &amp;&gt;&gt; 文件	以追加的方式，把正确输出和错误输出都保存到同一个文件当中。
正确输出和错误输出同时保存	命令 &gt;&gt; 文件1 2&gt;&gt;文件2	把正确的输出追加到文件1中，把错误的输出追加到文件2中。
</code></pre>
<p>&#x2F;dev&#x2F;null 文件<br>如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到**&#x2F;dev&#x2F;null**中</p>
<pre><code>[root@localhost ~]$  command &gt; dev/null
</code></pre>
<p>1<br>多命令顺序执行</p>
<table>
<thead>
<tr>
<th>多命令执行符</th>
<th>作用</th>
<th>格式</th>
</tr>
</thead>
<tbody><tr>
<td>；</td>
<td>命令1 ；命令2</td>
<td>多个命令顺序执行，命令之间没有任何逻辑联系</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>命令1 &amp;&amp; 命令2</td>
<td>当命令1正确执行（? &#x3D; 0 ） ， 则 命 令 2 才 会 执 行 当 命 令 1 执 行 不 正 确 （ ?&#x3D;0），则命令2才会执行 当命令1执行不正确（?&#x3D;0），则命令2才会执行当命令1执行不正确（?≠0），则命令2不会执行</td>
</tr>
<tr>
<td>ll</td>
<td>命令1 ll 命令2</td>
<td>当命令1执行不正确（? ≠ 0 ） ， 则 命 令 2 才 会 执 行 当 命 令 1 正 确 执 行 （ ?≠0），则命令2才会执行当命令1正确执行（?&#x3D;0），则命令2才会执行当命令1正确执行（?&#x3D;0），则命令2不会执行</td>
</tr>
</tbody></table>
<p>shell脚本的执行</p>
<pre><code>[root@localhost ~]$ vim test.sh
#!/bin/bash
echo “hello world”
</code></pre>
<p>两种方式执行shell脚本</p>
<p>第一种：给文件增加执行权限</p>
<pre><code>[root@localhost ~]$ chmod u+x test.sh
[root@localhost ~]$ ./test.sh  #绝对路径或相对路径执行
</code></pre>
<p>第二种（了解）：通过Bash调用执行脚本</p>
<pre><code>[root@localhost ~]$ bash test.sh
</code></pre>
<h2 id="三、shell变量"><a href="#三、shell变量" class="headerlink" title="三、shell变量"></a>三、shell变量</h2><p>什么是变量？<br>在一个脚本周期内,其值可以发生改变的量就是变量。</p>
<h3 id="1-变量的命名规则："><a href="#1-变量的命名规则：" class="headerlink" title="1. 变量的命名规则："></a>1. 变量的命名规则：</h3><p>在定义变量时，有一些规则需要遵守:</p>
<p>命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。<br>等号左右两侧不能有空格，可以使用下划线“_”，变量的值如果有空格，需要使用单引号或双引号包括。如:“test&#x3D;“hello world!””。其中双引号括起来的内容“$”，“(”和反引号都拥有特殊含义，而单引号括起来的内容都是普通字符。<br>不能使用标点符号，不能使用bash里的关键字（可用help命令查看保留关键字）。<br>环境变量建议大写，便于区分<br>如果需要增加变量的值，那么可以进行变量值的叠加。不过变量需要用双引号包含”$变量名”或用${变量名}包含变量名。</p>
<pre><code>[root@localhost ~]$ test=123
[root@localhost ~]$ test=&quot;$test&quot;456
[root@localhost ~]$ echo $test
123456
#叠加变量test，变量值变成了123456
[root@localhost ~]$ test=$&#123;test&#125;789
[root@localhost ~]$ echo $test
123456789
#再叠加变量test，变量值编程了123456789
</code></pre>
<p>关于单双引号的问题：</p>
<pre><code>双引号能够识别变量，双引号能够实现转义（类似于“\*”）
单引号是不能识别变量，只会原样输出，单引号是不能转义的
</code></pre>
<p><img src="https://s1.ax1x.com/2023/02/20/pSOHEwt.png" alt="pSOHEwt.png"></p>
<pre><code>[root@localhost ~]$ name=sc
#定义变量name 的值是sc（就是最正直的人，超哥我了!）
[root@localhost ~]$ echo &#39;$name&#39;
$name
#如果输出时使用单引号，则$name原封不动的输出
[root@localhost ~]$ echo &quot;$name&quot;
sc
#如果输出时使用双引号，则会输出变量name的值 sc

[root@localhost ~]$ echo `date`
2018年10月21日星期一18:16:33 CST
#反引号括起来的命令会正常执行
[root@localhost ~]$ echo &#39;`date`&#39;
`date`
#但是如果反引号命令被单引号括起来，那么这个命令不会执行，―date`会被当成普通字符输出
[root@localhost ~]$ echo &quot;`date&#39;&quot;
2018年10月21日星期一18:14:21 CST
#如果是双引号括起来，那么这个命令又会正常执行
</code></pre>
<p>反引号：</p>
<pre><code>[root@localhost ~]$ echo ls
ls
#如果命令不用反引号包含，命令不会执行，而是直接输出
[root@localhost ~]$ echo `ls`
anaconda-ks.cfginstall.loginstall.log.syslog sh test testfile
#只有用反引号包括命令，这个命令才会执行
[root@localhost ~]$ echo $(date)
2018年10月21日星期一18:25:09 CST
#使用$(命令)的方式也是可以的
</code></pre>
<h3 id="2-变量的分类："><a href="#2-变量的分类：" class="headerlink" title="2. 变量的分类："></a>2. 变量的分类：</h3><p>用户自定义变量: 这种变量是最常见的变量，由用户自由定义变量名和变量的值。</p>
<p>环境变量: 这种变量中主要保存的是和系统操作环境相关的数据，比如当前登录用户，用户的家目录，命令的提示符等。不是太好理解吧，那么大家还记得在Windows中，同一台电脑可以有多个用户登录，而且每个用户都可以定义自己的桌面样式和分辨率，这些其实就是Windows的操作环境，可以当做是Windows的环境变量来理解。环境变量的变量名可以自由定义，但是一般对系统起作用的环境变量的变量名是系统预先设定好的。</p>
<p>位置参数变量: 这种变量主要是用来向脚本当中传递参数或数据的，变量名不能自定义，变量作用是固定的。</p>
<p>预定义变量: 是Bash中已经定义好的变量，变量名不能自定义，变量作用也是固定的。</p>
<pre><code>变量分类	            名称	     作用	   内容
用户自定义变量	    自定义	     自定义	   自定义
用户自定义环境变量    自定义	     自定义	   自定义
系统自带环境变量(/etc/profile)	确定	确定	自定义
位置参数变量	    确定	    自定义	    自定义
预定义变量	    确定	    自定义	    自定义
</code></pre>
<h3 id="2-1-用户自定义变量："><a href="#2-1-用户自定义变量：" class="headerlink" title="2.1 用户自定义变量："></a>2.1 用户自定义变量：</h3><h4 id="2-1-1-变量定义"><a href="#2-1-1-变量定义" class="headerlink" title="2.1.1 变量定义"></a>2.1.1 变量定义</h4><pre><code>[root@localhost ~]$ 2name=&quot;shen chao&quot;
-bash: 2name=shen chao: command not found
#变量名不能用数字开头
[root@localhost ~]$ name = &quot;shenchao&quot;
-bash: name: command not found
#等号左右两侧不能有空格
[root@localhost ~]$ name=shen chao
-bash: chao: command not found
#变量的值如果有空格，必须用引号包含
</code></pre>
<h4 id="2-1-2-变量调用"><a href="#2-1-2-变量调用" class="headerlink" title="2.1.2 变量调用"></a>2.1.2 变量调用</h4><pre><code>[root@localhost ~]$ name=&quot;shen chao&quot;
#定义变量name
[root@localhost ~]$ echo $name #调用变量使用  $变量名
shen chao
#输出变量name的值
</code></pre>
<h4 id="2-1-3-变量查看"><a href="#2-1-3-变量查看" class="headerlink" title="2.1.3 变量查看"></a>2.1.3 变量查看</h4><pre><code>[root@localhost ~]$ set [选项]
选项:
-u:如果设定此选项，调用未声明变量时会报错（默认无任何提示）
-x:如果设定此选项，在命令执行之前，会把命令先输出一次
+&lt;参数&gt; :取消某个set曾启动的参数。

[root@localhost ~]$ set
BASH=/bin/bash
…省略部分输出…
name=&#39;shen chao&#39;
#直接使用set 命令，会查询系统中所有的变量，包含用户自定义变量和环境变量
[root@localhost ~]$ set -u
[root@localhost ~]$ echo $file
-bash: file: unbound variable
#当设置了-u选项后，如果调用没有设定的变量会有报错。默认是没有任何输出的。
[root@localhost ~]$ set -x
[root@localhost ~]$ ls
+ls --color=auto
anaconda-ks.cfginstall.loginstall.log.syslog sh tdir testtestfile
#如果设定了-x选项，会在每个命令执行之前，先把命令输出一次

[root@localhost ~]$ set +x
#取消启动的x参数
</code></pre>
<h4 id="2-1-4-变量删除"><a href="#2-1-4-变量删除" class="headerlink" title="2.1.4 变量删除"></a>2.1.4 变量删除</h4><pre><code>[root@localhost ~]$ unset 变量名
</code></pre>
<h3 id="2-2-环境变量："><a href="#2-2-环境变量：" class="headerlink" title="2.2 环境变量："></a>2.2 环境变量：</h3><h4 id="2-2-1-环境变量设置"><a href="#2-2-1-环境变量设置" class="headerlink" title="2.2.1 环境变量设置"></a>2.2.1 环境变量设置</h4><pre><code>[root@localhost ~]$  export age=&quot;18&quot;
#使用export声明的变量即是环境变量
</code></pre>
<h4 id="2-2-2-环境变量查询和删除"><a href="#2-2-2-环境变量查询和删除" class="headerlink" title="2.2.2 环境变量查询和删除"></a>2.2.2 环境变量查询和删除</h4><pre><code>env命令和set命令的区别：
set命令可以查看所有变量，而env命令只能查看环境变量。

[root@localhost ~]$ unset gender   #删除环境变量gender
[root@localhost ~]$ env | grep gender
</code></pre>
<h4 id="2-2-3-系统默认环境变量"><a href="#2-2-3-系统默认环境变量" class="headerlink" title="2.2.3 系统默认环境变量"></a>2.2.3 系统默认环境变量</h4><pre><code>[root@localhost ~]$ env
HOSTNAME=localhost.localdomain      #主机名
SHELL=/bin/bash                     #当前的shell
TERM=linux                          #终端环境
HISTSIZE=1000                       #历史命令条数
SSH_CLIENT=192.168.4.1594824 22     #当前操作环境是用ssh连接的，这里记录客户端ip
SSH_TTY=/dev/pts/1                  #ssh连接的终端时pts/1
USER=root                           #当前登录的用户
..........更多参数可以使用set和env命令查看.............
</code></pre>
<h3 id="2-3-位置参数变量："><a href="#2-3-位置参数变量：" class="headerlink" title="2.3 位置参数变量："></a>2.3 位置参数变量：</h3><pre><code>位置参数变量	作用
$n	n为数字，$0表示当前 Shell 脚本程序的名称，$1-9 代 表 第 一 到 第 九 个 参 数 , 十 以 上 的 参 数 需 要 用 大 括 号 包 含 ， 如 9代表第一到第九个参数,十以上的参数需要用大括号包含，如9代表第一到第九个参数,十以上的参数需要用大括号包含，如&#123;10&#125;
$*	这个变量代表命令行中所有的参数，$把所有的参数看成一个整体
$@	这个变量也代表命令行中所有的参数，不过$@把每个参数区分对待
$#	这个变量代表命令行中所有参数的个数
$1 是你给你写的shell脚本传的第一个参数，$2 是你给你写的shell脚本传的第二个参数…

[root@localhost sh]$ vim test.sh
#!/bin/sh
echo &quot;shell脚本本身的名字: $0&quot;
echo &quot;传给shell的第一个参数: $1&quot;
echo &quot;传给shell的第二个参数: $2&quot;
</code></pre>
<p>保存退出后，你在Test.sh所在的目录下输入 bash Test.sh 1 2</p>
<p>结果输出：</p>
<pre><code>shell脚本本身的名字: Test.sh
传给shell的第一个参数: 1
传给shell的第二个参数: 2
</code></pre>
<p>$*会把接收的所有参数当成一个整体对待，而$@则会区分对待接收到的所有参数。举个例子:</p>
<pre><code>[root@localhost sh]$ vi parameter2.sh
#!/bin/bash
for i in&quot;$*&quot;
#定义for循环，in后面有几个值，for会循环多少次，注意“$*”要用双引号括起来
#每次循环会把in后面的值赋予变量i
#Shell把$*中的所有参数看成是一个整体，所以这个for循环只会循环一次
do
    echo &quot;The parameters is: $i&quot;
    #打印变量$i的值
done
x=1
#定义变量x的值为1
for y in&quot;$@&quot;
#同样in后面的有几个值，for循环几次，每次都把值赋予变量y
#可是Shel1中把“$@”中的每个参数都看成是独立的，所以“$@”中有几个参数，就会循环几次
do
    echo &quot;The parameter$x is: $y&quot;
    #输出变量y的值
    x=$(( $x +1 ))
    #然变量x每次循环都加1，为了输出时看的更清楚
done
</code></pre>
<h3 id="2-4-预定义变量："><a href="#2-4-预定义变量：" class="headerlink" title="2.4 预定义变量："></a>2.4 预定义变量：</h3><p>预定义变量	作用</p>
<pre><code>$?	最后一次执行的命令的返回状态。如果这个变量的值为0，证明上一个命令正确执行;如果这个变量的值为非О(具体是哪个数，由命令自己来决定），则证明上一个命令执行不正确了。
$$	当前进程的进程号（PID)
$!	后台运行的最后一个进程的进程号(PID)
</code></pre>
<p>先来看看”$?”这个变量，举个例子说明</p>
<pre><code>[root@localhost sh]$ ls
count.sh hello.sh parameter2.sh parameter.sh
#ls命令正确执行
[root@localhost sh]$ echo $?
#预定义变量“$?”的值是0，证明上一个命令执行正确
[root@localhost sh]$ ls install.log
ls:无法访问install.log:没有那个文件或目录
#当前目录中没有install.log文件，所以ls命令报错了
[root@localhost sh]$ echo $?

#变量“$?”返回一个非О的值，证明上一个命令没有正确执行
#至于错误的返回值到底是多少，是在编写ls命令时定义好的，如果碰到文件不存在就返回数值2
</code></pre>
<p>再来说明下”$$”和”$!”这两个预定义变量</p>
<pre><code>[root@localhost sh]$ vi variable.sh
#!/bin/bash
echo &quot;The current process is $$&quot;
#输出当前进程的PID.
#这个PID就是variable.sh这个脚本执行时，生成的进程的PID
find /root -name hello.sh &amp;
#使用find命令在root目录下查找hello.sh文件
#符号&amp;的意思是把命令放入后台执行，工作管理我们在系统管理章节会详细介绍
echo &quot;The last one Daemon process is $!&quot;
#输出这个后台执行命令的进程的PID，也就是输出find命令的PID号
</code></pre>
<h3 id="3-只读变量："><a href="#3-只读变量：" class="headerlink" title="3. 只读变量："></a>3. 只读变量：</h3><pre><code>[root@localhost sh]$ vi readonly.sh
#!/bin/bash
a=10
#语法：readonly 变量名
readonly a
a=20   #会报错readonly variable
echo $a
</code></pre>
<h3 id="4-接受键盘输入："><a href="#4-接受键盘输入：" class="headerlink" title="4. 接受键盘输入："></a>4. 接受键盘输入：</h3><pre><code>[root@localhost ~]$ read [选项][变量名]
选项:
    -a 后跟一个变量，该变量会被认为是个数组，然后给其赋值，默认是以空格为分割符。
    -p： “提示信息”：在等待read输入时，输出提示信息
    -t： 秒数：read命令会一直等待用户输入，使用此选项可以指定等待时间
    -n： 数字：read命令只接受指定的字符数，就会执行
    -s： 隐藏输入的数据，适用于机密信息的输入
    -d： 后面跟一个标志符，其实只有其后的第一个字符有用，作为结束的标志。
    -e： 在输入的时候可以使用命令补全功能。
</code></pre>
<p>变量名:</p>
<pre><code>变量名可以自定义，如果不指定变量名，会把输入保存入默认变量REPLY.
如果只提供了一个变量名，则整个输入行赋予该变量.
如果提供了一个以上的变量名，则输入行分为若干字，一个接一个地赋予各个变量，而命令行上的最后一个变量取得剩余的所有字
</code></pre>
<p>写个例子来解释下read命令：</p>
<pre><code>[root@localhost sh]$ vi read.sh
#!/bin/bash

read -t 30 -p &quot;Please input your name: &quot; name
#提示“请输入姓名”并等待30 秒，把用户的输入保存入变量name 中
echo &quot;Name is $name&quot;
#看看变量“$name”中是否保存了你的输入

read -s -t 30 -p &quot;Please enter your age: &quot; age
#提示“请输入年龄”并等待30秒，把用户的输入保存入变量age中
#年龄是隐私，所以我们用“-s”选项隐藏输入
echo -e &quot;\n&quot;
#调整输出格式，如果不输出换行，一会的年龄输出不会换行
echo &quot;Age is $age&quot;

read -n 1 -t 30 -p &quot;Please select your gender[M/F]:&quot; gender
#提示“请选择性别”并等待30秒，把用户的输入保存入变量gender
#使用“-n1”选项只接收一个输入字符就会执行（都不用输入回车）
echo -e &quot;\n&quot;
echo &quot;Sex is $gender&quot;
</code></pre>
<h2 id="四、shell-运算符"><a href="#四、shell-运算符" class="headerlink" title="四、shell 运算符"></a>四、shell 运算符</h2><p>在shell中，运算符和其他编程脚本语言一样，常见的有算数运算符、关系运算符、逻辑运算符、字符串运算符、文件测试运算符等</p>
<h3 id="1-算数运算符"><a href="#1-算数运算符" class="headerlink" title="1. 算数运算符"></a>1. 算数运算符</h3><p>原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。<br>expr 是一款表达式计算工具，使用它能完成表达式的求值操作。<br>例如，两个数相加(注意使用的是反引号 &#96; 而不是单引号 ‘)：</p>
<pre><code>[root@localhost ~]$ vi computer.sh
#!/bin/bash
val=`expr 2 + 2`
echo &quot;两数之和为 : $val&quot;
#注意
#表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2，这与我们熟悉的大多数编程语言不一样。
#完整的表达式要被 ` ` 包含，注意这个字符不是常用的单引号，在 Esc 键下边。
</code></pre>
<p>下表列出了常用的算术运算符，假定变量 a 为 10，变量 b 为 20</p>
<pre><code>运算符	说明	举例
|加法 |expr $a + $b 结果为 30。
|减法 |expr $a - $b 结果为 -10。
*| 乘法 |expr $a \* $b 结果为 200。
/ |除法 |expr $b / $a 结果为 2。
% |取余| expr $b % $a 结果为 0。
= |赋值| a=$b 将把变量 b 的值赋给 a。
==| 相等。用于比较两个数字，相同则返回 true（真）。| [ $a == $b ] 返回 false（假）。
!= |不相等。用于比较两个数字，不相同则返回 true。 |[ $a != $b ] 返回 true。
注意：条件表达式要放在方括号之间，并且要有空格，必须写成 [ $a == $b ]。

[root@localhost ~]$ vi computers.sh
#!/bin/bash
a=10
b=20
echo &#39; &#39;
echo &#39;a+b= &#39; `expr $a + $b`
echo &#39;a-b= &#39; `expr $a - $b`
echo &#39;a*b= &#39; `expr $a \* $b`
echo &#39;a/b= &#39; `expr $a / $b`
echo &#39;a%b= &#39; `expr $a % $b`

#判断是否相等
if [ $a == $b ]
then
    echo &#39;a等于b&#39;
else
    echo &#39;a不等于b&#39;
fi
</code></pre>
<h3 id="2-关系运算符"><a href="#2-关系运算符" class="headerlink" title="2. 关系运算符"></a>2. 关系运算符</h3><p>关系运算符只支持数字，不支持字符串，除非字符串的值是数字。<br>下表列出了常用的关系运算符，假定变量 a 为 10，变量 b 为 20：</p>
<p>运算符	单词	说明	举例<br>-eq	equal	检测两个数是否相等，相等返回 true。	[ $a -eq $b ] 返回 false。<br>-ne	not equal	检测两个数是否相等，不相等返回 true。	[ $a -ne $b ] 返回 true。<br>-gt	great than	检测左边的数是否大于右边的，如果是，则返回 true。	[ $a -gt $b ] 返回 false。<br>-lt	less than	检测左边的数是否小于右边的，如果是，则返回 true。	[ $a -lt $b ] 返回 true。<br>-ge	great than or equal	检测左边的数是否大于等于右边的，如果是，则返回 true。	[ $a -ge $b ] 返回 false。<br>-le	less than or equal	检测左边的数是否小于等于右边的，如果是，则返回 true。	[ $a -le $b ] 返回 true。</p>
<pre><code>[root@localhost ~]$ [ 10 -gt 10 ] 
[root@localhost ~]$ echo $? 
1
[root@localhost ~]$ [ 10 -eq 10 ] 
[root@localhost ~]$ echo $? 
</code></pre>
<p>案例：判断当前输入的用户是否存在。如果存在则提示“用户存在”否则提示“用户不存在”。</p>
<p>如果要在shell脚本使用linux命令，可以使用$()包裹命令</p>
<pre><code>例如：disk_size=$(df -h | awk ‘NR==2 &#123;print $5&#125;’)

[root@localhost ~]$ vim demo.sh 
#!/bin/bash
#接受用户的输入
read -p &#39;请输入需要查询的用户名:&#39; username

#获取指定用户名在passwd文件中出现的次数
count=$(cat /etc/passwd | grep $username | wc -l)
#count=`cat /etc/passwd | grep $username | wc -l`

#判断出现的次数，如果次数=0则用户不存在，反之存在
if [  $count == 0 ]
then 
        echo &#39;用户不存在&#39;
    else 
        echo &#39;用户存在&#39;
fi
</code></pre>
<h3 id="3-逻辑运算符"><a href="#3-逻辑运算符" class="headerlink" title="3. 逻辑运算符"></a>3. 逻辑运算符</h3><p>下表列出了常用的布尔运算符，假定变量 a 为 10，变量 b 为 20：</p>
<pre><code>运算符	说明	举例
!	非运算，表达式为 true 则返回 false，否则返回 true。	[ ! false ] 返回 true。
-o	或（或者）运算，有一个表达式为 true 则返回 true。	[ $a -lt 20 -o $b -gt 100 ] 返回 true。
-a	与（并且）运算，两个表达式都为 true 才返回 true。	[ $a -lt 20 -a $b -gt 100 ] 返回 false。
或运算：一个为真即为真，全部为假才是假
与运算：一个为假即为假，全部为真才是真
</code></pre>
<h3 id="4-字符串运算符"><a href="#4-字符串运算符" class="headerlink" title="4. 字符串运算符"></a>4. 字符串运算符</h3><p>下表列出了常用的字符串运算符，假定变量 a 为 “abc”，变量 b 为 “efg”：</p>
<pre><code>运算符	说明	举例
=	检测两个字符串是否相等，相等返回 true。	[ $a = $b ] 返回 false。
!=	检测两个字符串是否相等，不相等返回 true。	[ $a != $b ] 返回 true。
-z	检测字符串长度是否为0，为0返回 true。	[ -z $a ] 返回 false。
-n	检测字符串长度是否为0，不为0返回 true。	[ -n $a ] 返回 true。
str	检测字符串是否为空，不为空返回 true。	[ $a ] 返回 true。
</code></pre>
<h3 id="5-文件测试运算符（重点）"><a href="#5-文件测试运算符（重点）" class="headerlink" title="5. 文件测试运算符（重点）"></a>5. 文件测试运算符（重点）</h3><p>文件测试运算符用于检测 Unix&#x2F;Linux 文件的各种属性。</p>
<pre><code>操作符	说明	举例
-b file	检测文件是否是块设备文件，如果是，则返回 true。	[ -b $file ] 返回 false。
-c file	检测文件是否是字符设备文件，如果是，则返回 true。	[ -c $file ] 返回 false。
-d file	检测文件是否是目录，如果是，则返回 true。	[ -d $file ] 返回 false。
-f file	检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。	[ -f $file ] 返回 true。
-g file	检测文件是否设置了 SGID 位，如果是，则返回 true。	[ -g $file ] 返回 false。
-k file	检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。	[ -k $file ] 返回 false。
-p file	检测文件是否是有名管道，如果是，则返回 true。	[ -p $file ] 返回 false。
-u file	检测文件是否设置了 SUID 位，如果是，则返回 true。	[ -u $file ] 返回 false。
-r file	检测文件是否可读，如果是，则返回 true。	[ -r $file ] 返回 true。
-w file	检测文件是否可写，如果是，则返回 true。	[ -w $file ] 返回 true。
-x file	检测文件是否可执行，如果是，则返回 true。	[ -x $file ] 返回 true。
-s file	检测文件是否为空（文件大小是否大于0），不为空返回 true。	[ -s $file ] 返回 true。
-e file	检测文件（包括目录）是否存在，如果是，则返回 true。	[ -e $file ] 返回 true。
注意：权限几个判断，如果只有一个部分符合，则认为是有权限的。
</code></pre>
<h2 id="五、流程控制"><a href="#五、流程控制" class="headerlink" title="五、流程控制"></a>五、流程控制</h2><h3 id="1-if条件判断"><a href="#1-if条件判断" class="headerlink" title="1. if条件判断"></a>1. if条件判断</h3><h4 id="1-1-单分支if条件"><a href="#1-1-单分支if条件" class="headerlink" title="1.1 单分支if条件"></a>1.1 单分支if条件</h4><p>语法：</p>
<pre><code>if [ 条件判断式 ]
    then
        程序
fi
</code></pre>
<p>案例：统计根分区使用率</p>
<pre><code>[root@localhost ~]$ vi sh/if1.sh
#!/bin/bash

#统计根分区使用率
rate=$(df -h | grep &quot;/dev/sda2&quot; | awk &#39;&#123;print $5&#125;’| cut -d &quot;%&quot;-f1)
#把根分区使用率作为变量值赋予变量rate
if [ $rate -ge 80 ]
#判断rate的值如果大于等于80，则执行then程序
    then
        echo &quot;Warning!/dev/sda3 is fu11!!&quot;
    #打印警告信息。在实际工作中，也可以向管理员发送邮件。
fi
</code></pre>
<p>案例：创建目录</p>
<pre><code>[root@localhost ~]$ vi sh/add_dir.sh
#!/bin/bash
#创建目录，判断是否存在，存在就结束，反之创建
echo &quot;当前脚本名称为$0&quot;
DIR=&quot;/media/cdrom&quot;
if [ ! -e $DIR ]
then
    mkdir -p $DIR
fi
echo &quot;$DIR 创建成功&quot;
</code></pre>
<h4 id="1-2-双分支if条件语句"><a href="#1-2-双分支if条件语句" class="headerlink" title="1.2 双分支if条件语句"></a>1.2 双分支if条件语句</h4><p>语法：</p>
<pre><code>if [ 条件判断式 ]
    then
        条件成立时，执行的程序
    else
        条件不成立时，执行的另一个程序
fi
</code></pre>
<p>案例1：备份mysql数据库</p>
<pre><code>[root@localhost ~]$ vi sh/bakmysql.sh
#!/bin/bash
#备份mysql数据库。

ntpdate asia.pool.ntp.org &amp;&gt;/dev/null
#同步系统时间
date=$(date +%y%m%d)
#把当前系统时间按照“年月日”格式赋子变量date
size=$(du -sh/var/lib/mysql)
#统计mysql数据库的大小，并把大小赋予size变量

if [ -d /tmp/dbbak ]
#判断备份目录是否存在，是否为目录
    then
    #如果判断为真，执行以下脚本
    echo &quot;Date : $date!&quot; &gt; /tmp/dbbak/dbinfo.txt
    #把当前日期写入临时文件
    echo &quot;Data size : $size&quot; &gt;&gt; /tmp/dbbak/dbinfo.txt
    #把数据库大小写入临时文件
    cd/tmp/dbbak
    
    #进入备份目录
    tar -zcf mysql-lib-$date.tar.gz /var/lib/mysql dbinfo.txt &amp;&gt; /dev/null
    #打包压缩数据库与临时文件，把所有输出丢入垃圾箱（不想看到任何输出）
    rm -rf /tmp/dbbak/dbinfo.txt
    #删除临时文件
else
    mkdir /tmp/dbbak
    #如果判断为假，则建立备份目录
    echo &quot;Date : $date!&quot; &gt; /tmp/dbbak/dbinfo.txt
    echo &quot;Data size : $size&quot; &gt;&gt; /tmp/dbbak/dbinfo.txt
    #把日期和数据库大小保存如临时文件
    cd /tmp/dbbak
    tar -zcf mysql-lib-$date.tar. gz dbinfo.txt /var/lib/mysql &amp;&gt; /dev/null
    #压缩备份数据库与临时文件
    rm -rf/tmp/dbbak/dbinfo.txt
    #删除临时文件
fi
</code></pre>
<p>案例2：判断apache是否启动，如果没有启动则自动启动</p>
<pre><code>[root@localhost ~]$ vi sh/autostart.sh
#!/bin/bash
#判断apache是否启动，如果没有启动则自动启动

port=$(nmap -sT 192.168.4.210 | grep tcp | grep http | awk &#39;&#123;print $2&#125;’)
#使用nmap命令扫描服务器，并截取 apache服务的状态，赋予变量port
#只要状态是open，就证明正常启动
if [ &quot;$port&quot; == &quot;open&quot;]
#如果变量port的值是“open”
    then
    echo &quot;$(date) httpd is ok!” &gt;&gt; /tmp/autostart-acc.log
    #则证明apache 正常启动，在正常日志中写入一句话即可
else
    /etc/rc.d/init.d/httpd start &amp;&gt;/dev/null
    #否则证明apache没有启动，自动启动apache
    echo &quot;$(date) restart httpd !!&quot; &gt;&gt; /tmp/autostart-err.log
    #并在错误日志中记录自动启动apche 的时间
fi
</code></pre>
<p>nmap端口扫描命令，格式如下：</p>
<pre><code>[root@localhost ~]$ nmap -sT 域名或IP
选项:
-s      扫描
-T      扫描所有开启的TCP端口

#知道了nmap命令的用法，我们在脚本中使用的命令就是为了截取http的状态，只要状态是“or.

#就证明apache启动正常，否则证明apache启动错误。来看看脚本中命令的结果:
[root@localhost ~]$ nmap -sT 192.168.4.210 | grep tcp | grep http | awk &#39; fprint $2&#125;’
#扫描指定计算机，提取包含tcp 的行，在提取包含httpd 的行，截取第二列open
#把截取的值赋予变量port
</code></pre>
<h4 id="1-3-多分支if条件语句"><a href="#1-3-多分支if条件语句" class="headerlink" title="1.3 多分支if条件语句"></a>1.3 多分支if条件语句</h4><p>语法：</p>
<pre><code>if [ 条件判断式1 ]
    then
        当条件判断式1成立时，执行程序1
elif [ 条件判断式2 ]
    then
        当条件判断式2成立时，执行程序2
…省略更多条件…
else
    当所有条件都不成立时，最后执行此程序
fi
</code></pre>
<p>案例：判断用户输入的是什么文件</p>
<pre><code>[root@localhost ~]$ vi sh/if-elif.sh
#!/bin/bash
#判断用户输入的是什么文件

read -p &quot;Please input a filename: &quot; file
#接收键盘的输入，并赋予变量file
if [ -z &quot;$file” ]
#判断file变量是否为空
    then
        echo &quot;Error, please input a filename&quot;
        #如果为空，执行程序1，也就是输出报错信息
        exit 1
        #退出程序，并返回值为Ⅰ(把返回值赋予变量$P）
elif [ ! -e &quot;$file” ]
        #判断file的值是否存在
        then
        echo &quot;Your input is not a file!&quot;
        #如1果不存在，则执行程序2
        exit 2
        #退出程序，把并定义返回值为2
elif [ -f &quot;$file” ]
        #判断file的值是否为普通文件
        then
        echo &quot;$file is a regulare file!”
        #如果是普通文件，则执行程序3
elif [ -d &quot;$file” ]
        #到断file的值是否为目录文件
        then
        echo &quot;$file is a directory!&quot;
        #如果是目录文件，网执行程序4
else
    echo &quot;$file is an other file!”
    #如果以上判断都不是，则执行程序5
fi
</code></pre>
<h3 id="2-多分支case条件语句"><a href="#2-多分支case条件语句" class="headerlink" title="2. 多分支case条件语句"></a>2. 多分支case条件语句</h3><p>case语句和if…elif…else语句一样都是多分支条件语句,不过和if多分支条件语句不同的是，case语句只能判断一种条件关系，而if语句可以判断多种条件关系。</p>
<p>case语句语法如下:</p>
<pre><code>case $变量名 in
    &quot;值1&quot;)
    如果变量的值等于值1，则执行程序1
    ;;
    &quot;值2&quot;)
    如果变量的值等于值2，则执行程序2
    ::
    …省略其他分支…
    *)
    如果变量的值都不是以上的值，则执行此程序
    ;;
esac
</code></pre>
<p>这个语句需要注意以下内容:</p>
<pre><code>case语句，会取出变量中的值，然后与语句体中的值逐一比较。如果数值符合，则执行对应的程序，如果数值不符，则依次比较下一个值。如果所有的值都不符合，则执行 “*)” (*代表所有其他值）中的程序。
case语句以“case”开头，以“esac”结尾。
每一个分支程序之后要通过“;;”双分号结尾，代表该程序段结束(千万不要忘记，每次写case语句，都不要忘记双分号）。
</code></pre>
<p>案例：</p>
<pre><code>[root@localhost ~]$ vi sh/if-case.sh
#!/bin/bash
read -p &quot;请输入一个字符，并按Enter确认：&quot; KEY
case &quot;$KEY&quot; in
    [a-z]|[A-Z])
    echo &quot;您输入的是字母&quot;
    ;;
    
    [0-9])
    echo &quot;您输入的是数字&quot;
    ;;
    
    *)
    echo &quot;您输入的是其他字符&quot;
    ;;
esac
</code></pre>
<h3 id="3-for循环"><a href="#3-for循环" class="headerlink" title="3. for循环"></a>3. for循环</h3><pre><code>for循环是固定循环，也就是在循环时已经知道需要进行几次的循环，有时也把for循环称为计数循环。for的语法有如下两种:
</code></pre>
<p>语法一:</p>
<pre><code>for 变量 in 值1 值2 值3 …(可以是一个文件等)
    do
        程序
    done
    
    这种语法中for循环的次数，取决于in后面值的个数（空格分隔），有几个值就循环几次，并且每次循环都把值赋予变量。
    也就是说，假设in后面有三个值，for会循环三次，第一次循环会把值1赋予变量，第二次循环会把值2赋予变量，以此类推。
</code></pre>
<p>语法二:</p>
<pre><code>for (( 初始值;循环控制条件;变量变化 ))
    do
        程序
    done
</code></pre>
<p>语法二中需要注意:<br>初始值:在循环开始时，需要给某个变量赋予初始值，如i&#x3D;1;</p>
<p>循环控制条件:用于指定变量循环的次数，如i&lt;&#x3D;100，则只要i的值小于等于100，循环就会继续;</p>
<p>变量变化:每次循环之后，变量该如何变化，如i&#x3D;i+1。代表每次循环之后，变量i的值都加1。</p>
<p>语法一举例：打印时间</p>
<pre><code>[root@localhost ~]$ vi sh/for.sh
#!/bin/bash
#打印时间

for time in morning noon afternoon evening
    do
        echo &quot;This time is $time!&quot;
    done
</code></pre>
<p>语法一举例：批量解压缩脚本</p>
<pre><code>[root@localhost ~]$ vi sh/auto-tar. sh
#!/bin/bash
#批量解压缩脚本

cd/lamp
#进入压缩包目录
ls *.tar.gz &gt; ls.log
#把所有.tar.gz结尾的文件的文件覆盖到ls.log 临时文件中
for i in $(cat ls.log) `
#或者这样写for i in `cat ls.log`

#读取ls.log文件的内容，文件中有多少个值，就会循环多少次，每次循环把文件名赋予变量i
    do
        tar -zxf $i &amp;&gt;/dev/null
        #加压缩，并把所有输出都丢弃
    done
rm -rf /lamp/ls.log
#删除临时文件ls.log
</code></pre>
<p>语法二举例：从1加到100</p>
<pre><code>[root@localhost ~]$ vi sh/add. sh
#!/bin/bash
#从1加到100

s=0
for (( i=1;i&lt;=100;i=i+1 ))
#定义循环100 次
do
    s=$(( $s+$i ))
    #每次循环给变量s赋值
    done
echo &quot;The sum of 1+2+...+100 is : $s&quot;
#输出1加到100的和
</code></pre>
<p>语法二举例：批量添加指定数量的用户</p>
<pre><code>[root@localhost ~]$ vi useradd.sh
#!/bin/bash
#批量添加指定数量的用户

read -p &quot;Please input user name: &quot; -t 30 name
#让用户输入用户名，把输入保存入变量name

read -p &quot;Please input the number of users: &quot; -t 30 num
#让用户输入添加用户的数量，把输入保存入变量num

read -p &quot;Please input the password of users: &quot; -t 30 pass
#让用户输入初始密码，把输入保存如变量pass

if [ ! -z &quot;$name&quot; -a ! -z &quot;$num&quot;-a ! -z &quot;$pass&quot;]
#判断三个变量不为空
then
y=$(echo $num | sed &#39;s/[0-9]//g&#39;)
#定义变量的值为后续命令的结果
#后续命令作用是，把变量num 的值替换为空。如果能替换为空，证明num 的值为数字
#如果不能替换为空，证明num的值为非数字。我们使用这种方法判断变量num 的值为数字
    if [ -z &quot;$y&quot;]
    #如果变量y的值为空，证明num变量是数字
        then
        for (( i=1 ; i&lt;=$num; i=i+1 ))
        #循环num变量指定的次数
            do
            /usr/sbin/useradd $name$i &amp;&gt;/dev/null
            #添加用户，用户名为变量name 的值加变量i的数字
            echo $pass | /usr/bin/passwd --stdin $name$i &amp;&gt;/dev/null
            #给用户设定初始密码为变量pass 的值
            done
    fi
fi
</code></pre>
<p>语法二举例：批量删除用户</p>
<pre><code>[root@localhost ~]$ vi sh/userdel.sh
#!/bin/bash
#批量删除用户

user=$(cat /etc/passwd | grep &quot; /bin/bash&quot;|grep -v &quot;root&quot;Icut -d &quot;:&quot; -f 1)
#读取用户信息文件，提取可以登录用户，取消root用户，截取第一列用户名

for i in $user
#循环，有多少个普通用户，循环多少次
    do
        userdel -r $i
        #每次循环，删除指定普通用户
    done
</code></pre>
<h3 id="4-while循环"><a href="#4-while循环" class="headerlink" title="4. while循环"></a>4. while循环</h3><p>对while循环来讲，只要条件判断式成立，循环就会一直继续，直到条件判断式不成立，循环才会停止。</p>
<p>语法：</p>
<pre><code>while [ 条件判断式 ]
    do
        程序
    done
</code></pre>
<p>案例：1加到100</p>
<pre><code>[root@localhost ~]$ vi sh/addnum.sh
#!/bin/bash
#从1加到100

i=1
s=0
#给变量i和变量s赋值

while [ $i -le 100 ]
#如果变量i的值小于等于100，则执行循环
    do
        s=$(( $s+$i ))
        i=$(( $i+1 ))
    done
echo &quot;The sum is: $s&quot;
</code></pre>
<p>案例：输入的数值进行比较判断</p>
<pre><code>[root@localhost ~]$ vi sh/addnum.sh
#!/bin/bash
PRICE=$(expr $RANDOM % 1000)
TIMES=0

echo &quot;商品的价格为0-999之间，猜猜看是多少？&quot;
while true
do
read -p &quot;请输入您猜的价格：&quot; INT
let TIMES++

    if [ $INT -eq $PRICE ] ; then
    echo &quot;恭喜您猜对了，实际价格是 $PRICE&quot;
    echo &quot;您总共猜了 $TIMES 次&quot;
    exit 0
    elif [ $INT -gt $PRICE ] ; then
    echo &quot;太高了&quot;
    else
    echo &quot;太低了&quot;
    fi
done
</code></pre>
<h3 id="5-until循环"><a href="#5-until循环" class="headerlink" title="5. until循环"></a>5. until循环</h3><p>和while循环相反，until循环时只要条件判断式不成立则进行循环，并执行循环程序。一旦循环条件成立，则终止循环。</p>
<p>语法:</p>
<pre><code>until [ 条件判断式 ]
    do
        程序
    done
</code></pre>
<p>案例一：1加到100</p>
<pre><code>[root@localhost ~]$ vi sh/until.sh
#!/bin/bash
#从1加到100

i=1
s=0
#t给变量i和变量s赋值

until [ $i -gt 100 ]
#循环直到变量i的值大于100，就停止循环
    do
        s=$(( $s+$i ))
        i=$(( $i+1 ))
    done
echo &quot;The sum is: $s&quot;
</code></pre>
<h3 id="6-函数"><a href="#6-函数" class="headerlink" title="6. 函数"></a>6. 函数</h3><p>语法：</p>
<pre><code>function 函数名 () &#123;
    程序
&#125;
</code></pre>
<p>案例：接收用户输入的数字，然后从1加到这个数字</p>
<pre><code>[root@localhost ~]$ vi sh/function.sh
#!/bin/bash
#接收用户输入的数字，然后从1加到这个数字

function sum () &#123;
    #定义函数sum
    s=0
    for (( i=0; i&lt;=$num;i=i+1 ))
        #循环直到i大于$1为止。$1是函数sum 的第一个参数
        #在函数中也可以使用位置参数变量，不过这里的$1指的是函数的第一个参数
        do
            s=$(( $i+$s ))
        done
    echo &quot;The sum of 1+2+3...+$1 is :$s&quot;
    #输出1加到$1的和
&#125;

read -p &quot;Please input a number: &quot; -t 30 num
#接收用户输入的数字，并把值赋予变量num
y=$(echo $num | sed &#39;s/[0-9]//g&#39;)
#把变量num的值替换为空，并赋予变量y

if [ -z &quot;$y&quot;]
#判断变量y是否为空，以确定变量num中是否为数字
    then
        sum $num
        #调用sum函数，并把变量num的值作为第一个参数传递给sum函数
else
        echo &quot;Error!! Please input a number!&quot;
        #如果变量num 的值不是数字，则输出报错信息
fi
</code></pre>
<h3 id="7-特殊流程控制语句"><a href="#7-特殊流程控制语句" class="headerlink" title="7. 特殊流程控制语句"></a>7. 特殊流程控制语句</h3><h4 id="7-1-exit语句"><a href="#7-1-exit语句" class="headerlink" title="7.1 exit语句"></a>7.1 exit语句</h4><p>系统是有exit命令的，用于退出当前用户的登录状态。可是在Shell脚本中，exit语句是用来退出当前脚本的。也就是说，在Shell脚本中，只要碰到了exit语句，后续的程序就不再执行，而直接退出脚本。</p>
<p>exit的语法如下:</p>
<pre><code>exit [返回值]
</code></pre>
<p>如果exit命令之后定义了返回值，那么这个脚本执行之后的返回值就是我们自己定义的返回值。可以通过查询$?这个变量，来查看返回值。如果exit之后没有定义返回值，脚本执行之后的返回值是执行exit 语句之前，最后执行的一条命令的返回值。写一个exit 的例子:</p>
<pre><code>[root@localhost ~]$ vi sh/exit.sh
#!/bin/bash
#演示exit的作用

read -p &quot;Please input a number: &quot; -t 30 num
#接收用户的输入，并把输入赋予变量num
y=$ (echo $num | sed &#39;s/[0-9]//g&#39;)
#如果变量num 的值是数字，则把num的值替换为空，否则不替换
#把替换之后的值赋予变量y
[ -n &quot;$y&quot; ] &amp;&amp; echo &quot;Error! Please input a number!&quot; &amp;&amp; exit 18
#判断变量y的值如果不为空，输出报错信息，退出脚本，退出返回值为18
echo &quot;The number is: $num&quot;
#如果没有退出加班，则打印变量num中的数字
</code></pre>
<h4 id="7-2-break语句"><a href="#7-2-break语句" class="headerlink" title="7.2 break语句"></a>7.2 break语句</h4><p>当程序执行到break语句时，会结束整个当前循环。而continue 语句也是结束循环的语句，不过continue 语句单次当前循环，而下次循环会继续。</p>
<p>案例：</p>
<pre><code>[root@localhost ~]$ vi sh/break.sh
#!/bin/bash
#演示break 跳出循环

for (( i=1;i&lt;=10; i=i+1 ))
#循环十次
    do
        if [&quot;$i&quot; -eq 4 ]
        #如果变量i的值等于4
            then
            break
            #退出整个循环
        fi
    echo $i
    #输出变量i的值
    done
</code></pre>
<p>执行下这个脚本，因为一旦变量i的值等于4，整个循环都会跳出，所以应该只能循环三次:</p>
<pre><code>[root@localhost ~]$ chmod 755 sh/break.sh
[root@localhost ~]#sh/break.sh
</code></pre>
<h4 id="7-3-continue语句"><a href="#7-3-continue语句" class="headerlink" title="7.3 continue语句"></a>7.3 continue语句</h4><p>continue也是结束流程控制的语句。如果在循环中，continue语句只会结束单次当前循环。</p>
<p>案例：</p>
<pre><code>[root@localhost ~]$ vi sh/break.sh
#!/bin/bash
#演示continue

for (( i=1;i&lt;=10;i=i+1 ))
#循环十次
    do
        if [&quot;$i&quot; -eq 4 ]
        #如果变量i的值等于4
            then
            continue
            #退出换成continue
        fi
    echo $i
    #输出变量i的值
    done
</code></pre>
<p>执行下这个脚本:</p>
<pre><code>[root@localhost ~]$ chmod 755 sh/continue.sh
[root@localhost ~]#sh/break.sh
#少了4这个输出
</code></pre>
<h2 id="六、字符截取、替换和处理命令"><a href="#六、字符截取、替换和处理命令" class="headerlink" title="六、字符截取、替换和处理命令"></a>六、字符截取、替换和处理命令</h2><p>正则表达式</p>
<pre><code>元字符	描述	示例
\	转义符，将特殊字符进行转义，忽略其特殊意义	a.b匹配a.b，但不能匹配ajb，.被转义为特殊意义
^	匹配行首，awk中，^则是匹配字符串的开始	^tux匹配以tux开头的行
$	匹配行尾，awk中，$则是匹配字符串的结尾	tux$匹配以tux结尾的行
.	匹配除换行符\n之外的任意单个字符	ab.匹配abc或abd，不可匹配abcd或abde，只能匹配单字符
[ ]	匹配包含在[字符]之中的任意一个字符	coo[kl]可以匹配cook或cool
[^]	匹配[^字符]之外的任意一个字符	123[^45]不可以匹配1234或1235，1236、1237都可以
[-]	匹配[]中指定范围内的任意一个字符，要写成递增	[0-9]可以匹配1、2或3等其中任意一个数字
?	匹配之前的项1次或者0次	colou?r可以匹配color或者colour，不能匹配colouur
| 匹配之前的项1次或者多次 | sa-6+匹配sa-6、sa-666，不能匹配sa-
| 匹配之前的项0次或者多次| co*l匹配cl、col、cool、coool等
() | 匹配表达式，创建一个用于匹配的子串 | ma(tri)?匹配max或maxtrix
&#123;n&#125; | 匹配之前的项n次，n是可以为0的正整数 |[0-9]&#123;3&#125;匹配任意一个三位数，可以扩展为[0-9][0-9][0-9]
&#123;n,&#125;| 之前的项至少需要匹配n次 | [0-9]&#123;2,&#125;匹配任意一个两位数或更多位数不支持&#123;n,&#125;&#123;n,&#125;&#123;n,&#125;
&#123;n,m&#125;| 指定之前的项至少匹配n次，最多匹配m次，n&lt;=m | [0-9]&#123;2,5&#125;匹配从两位数到五位数之间的任意一个数字
|| 交替匹配|两边的任意一项 | ab(c|d)匹配abc或abd
</code></pre>
<h3 id="1-字符截取、替换命令"><a href="#1-字符截取、替换命令" class="headerlink" title="1 字符截取、替换命令"></a>1 字符截取、替换命令</h3><h4 id="1-1-cut-列提取命令"><a href="#1-1-cut-列提取命令" class="headerlink" title="1.1 cut 列提取命令"></a>1.1 cut 列提取命令</h4><pre><code>[root@localhost ~]$ cut [选项] 文件名
选项:
-f 列号: 提取第几列
-d 分隔符: 按照指定分隔符分割列
-n	取消分割多字节字符
-c 字符范围: 不依赖分隔符来区分列，而是通过字符范围（行首为0）来进行字段提取。“n-”表示从第n个字符到行尾;“n-m”从第n个字符到第m个字符;“一m”表示从第1个字符到第m个字符。
--complement	补足被选择的字节、字符或字段
--out-delimiter	指定输出内容是的字段分割符
</code></pre>
<p>cut命令的默认分隔符是制表符，也就是“tab”键，不过对空格符可是支持的不怎么好啊。我们先建立一个测试文件，然后看看cut命令的作用吧:</p>
<pre><code>[root@localhost ~]$ vi student.txt
id	name	gender	mark
1	liming	m		86
2	sc		m		67
3	tg		n		90

[root@localhost ~]$ cut -f 2 student.txt
#提取第二列内容
</code></pre>
<p>那如果想要提取多列呢?只要列号直接用“，”分开，命令如下:</p>
<pre><code>[root@localhost ~]$ cut -f 2,3 student.txt
</code></pre>
<p>cut可以按照字符进行提取，需要注意“8-”代表的是提取所有行的第十个字符开始到行尾，而“10-20”代表提取所有行的第十个字符到第二十个字符，而“-8”代表提取所有行从行首到第八个字符:</p>
<pre><code>[root@localhost ~]$ cut -c 8- student.txt
#提取第八个字符开始到行尾，好像很乱啊，那是因为每行的字符个数不相等啊

[root@localhost ~]$ cut -d &quot;:&quot; -f 1,3 /etc/passwd
#以“:”作为分隔符，提取/etc/passwd_文件的第一列和第三列
</code></pre>
<p>如果我想用cut命令截取df命令的第一列和第三列，就会出现这样的情况:</p>
<pre><code>[root@localhost~]$ df -h | cut -d &quot; &quot; -f 1,3
Filesystem 
/dev/sda2 
tmpfs 
/dev/sda1
</code></pre>
<h4 id="1-2-awk-编程"><a href="#1-2-awk-编程" class="headerlink" title="1.2 awk 编程"></a>1.2 awk 编程</h4><h5 id="1-2-1-awk-概述"><a href="#1-2-1-awk-概述" class="headerlink" title="1.2.1 awk 概述"></a>1.2.1 awk 概述</h5><pre><code>AWK 是一种处理文本文件的语言，是一个强大的文本分析工具。
</code></pre>
<h5 id="1-2-2-printf-格式化输出"><a href="#1-2-2-printf-格式化输出" class="headerlink" title="1.2.2 printf 格式化输出"></a>1.2.2 printf 格式化输出</h5><pre><code>[root@localhost ~]$ printf ‘输出类型输出格式’ 输出内容

输出类型:
%c:     ASCII字符.显示相对应参数的第一个字符
%-ns:   输出字符串，减号“-”表示左对齐(默认右对齐)，n是数字指代输出几个字符,几个参数就写几个%-ns
%-ni:   输出整数，n是数字指代输出几个数字
%f：    输出小数点右边的位数
%m.nf:  输出浮点数，m和n是数字，指代输出的整数位数和小数位数。如%8.2f代表共输出8位数，其中2位是小数，6位是整数。

输出格式:
\a: 输出警告声音
\b: 输出退格键，也就是Backspace键
\f: 清除屏幕
\n: 换行
\r: 回车，也就是Enter键
\t: 水平输出退格键，也就是Tab 键
\v: 垂直输出退格键，也就是Tab 键
</code></pre>
<p>为了演示printf命令，我们需要修改下刚刚cut命令使用的student.txt文件，文件内容如下:</p>
<pre><code>[root@localhost ~]$ vi student.txt
ID      Name    php  	 Linux  	MySQL 	  Average
1       AAA      66         66       66           66
2       BBB      77         77       77           77
3       CCC      88         88       88           88

#printf格式输出文件
[root@localhost ~]$ printf &#39;%s\t %s\t %s\t %s\t %s\t %s\t \n’ $(cat student.txt)
#%s分别对应后面的参数,6列就写6个
ID      Name    php   Linux  MySQL   Average
1       AAA      66         66       66           66
2       BBB      77         77       77           77
3       CCC      88         88       88           88
</code></pre>
<p>如果不想把成绩当成字符串输出，而是按照整型和浮点型输出，则要这样:</p>
<pre><code>[root@localhost ~]$ printf &#39;%i\t %s\t %i\t %i\t %i\t %8.2f\t \n’ \ $(cat student.txt | grep -v Name)
</code></pre>
<h5 id="1-2-3-awk-基本使用"><a href="#1-2-3-awk-基本使用" class="headerlink" title="1.2.3 awk 基本使用"></a>1.2.3 awk 基本使用</h5><pre><code>[root@localhost ~]$ awk‘条件1&#123;动作1&#125; 条件2&#123;动作2&#125;…’ 文件名
条件（Pattern）:
    一般使用关系表达式作为条件。这些关系表达式非常多，例如:
    x &gt; 10  判断变量x是否大于10
    x == y  判断变量x是否等于变量y
    A ~ B   判断字符串A中是否包含能匹配B表达式的子字符串
    A !~ B  判断字符串A中是否不包含能匹配B表达式的子字符串
    
动作（Action） :
    格式化输出
    流程控制语句

常用参数：

-F	指定输入时用到的字段分隔符
-v	自定义变量
-f	从脚本中读取awk命令
-m	对val值设置内在限制
</code></pre>
<p>我们这里先来学习awk基本用法，也就是只看看格式化输出动作是干什么的。</p>
<pre><code>[root@localhost ~]$ awk &#39;&#123;printf $2 &quot;\t&quot; $6 &quot;\n&quot;&#125;’ student.txt
#输出第二列和第六列
</code></pre>
<p>比如刚刚截取df命令的结果时，cut命令已经力不从心了，我们来看看awk命令:</p>
<pre><code>[root@localhost ~]$ df -h | awk &#39;&#123;print $1 &quot;\t&quot; $3&#125;&#39;
#截取df命令的第一列和第三列
</code></pre>
<h5 id="1-2-4-awk-的条件"><a href="#1-2-4-awk-的条件" class="headerlink" title="1.2.4 awk 的条件"></a>1.2.4 awk 的条件</h5><pre><code>条件的类型	条件	说明
awk保留字	BEGIN	在awk程序一开始时，尚未读取任何数据之前执行。BEGIN后的动作只在程序开始时执行一次
awk保留字	END	在awk程序处理完所有数据，即将结束时执行。END后的动作只在程序结束时执行一次
关系运算符	&gt;	大于
关系运算符	&lt;	小于
关系运算符	&gt;=	大于等于
关系运算符	&lt;=	小于等于
关系运算符	==	等于。用于判断两个值是否相等，如果是给变量赋值，请使用“”号
关系运算符	!=	不等于
关系运算符	A~B	判断字符串A中是否包含能匹配B表达式的子字符串
关系运算符	A!~B	判断字符串A中是否不包含能匹配B表达式的子字符串
正则表达式	/正则/	如果在&quot;//&quot;中可以写入字符，也可以支持正则表达式
</code></pre>
<p>BEGIN<br>BEGIN是awk的保留字，是一种特殊的条件类型。BEGIN的执行时机是“在 awk程序一开始时，尚未读取任何数据之前执行”。一旦BEGIN后的动作执行一次，当awk开始从文件中读入数据，BEGIN的条件就不再成立，所以BEGIN定义的动作只能被执行一次。<br>例如:</p>
<pre><code>[root@localhost ~]$ awk &#39;BEGIN&#123;printf &quot;This is a transcript \n&quot; &#125; &#123;printf $2 &quot;\t&quot; $6 &quot;\n&quot;&#125;’ student.txt
#awk命令只要检测不到完整的单引号不会执行，所以这个命令的换行不用加入“|”,就是一行命令
#这里定义了两个动作
#第一个动作使用BEGIN条件，所以会在读入文件数据前打印“这是一张成绩单”(只会执行一次)
#第二个动作会打印文件的第二字段和第六字段
</code></pre>
<p>END<br>END也是awk保留字，不过刚好和BEGIN相反。END是在awk程序处理完所有数据，即将结束时执行。END后的动作只在程序结束时执行一次。例如:</p>
<pre><code>[root@localhost ~]$ awk &#39;END&#123;printf &quot;The End \n&quot;&#125; &#123;printf $2 &quot;\t&quot; $6 &quot;\n&quot;&#125;’ student.txt
#在输出结尾输入“The End”，这并不是文档本身的内容，而且只会执行一次
</code></pre>
<p>关系运算符<br>举几个例子看看关系运算符。假设我想看看平均成绩大于等于87分的学员是谁，就可以这样输入命令:<br>例子1:</p>
<pre><code>[root@localhost ~]$ cat student.txt | grep -v Name | awk &#39;$6 &gt;= 87 &#123;printf $2 &quot;\n&quot;&#125;&#39;
#使用cat输出文件内容，用grep取反包含“Name”的行
#判断第六字段（平均成绩）大于等于87分的行，如果判断式成立，则打第六列（学员名$2）
</code></pre>
<p>加入了条件之后，只有条件成立动作才会执行，如果条件不满足，则动作则不运行。通过这个实验，大家可以发现，虽然awk是列提取命令，但是也要按行来读入的。这个命令的执行过程是这样的:</p>
<pre><code>1）如果有BEGIN条件，则先执行BEGIN定义的动作。
2）如果没有BEGIN条件，则读入第一行，把第一行的数据依次赋予$0、$1、$2等变量。其中$0代表此行的整体数据，$1代表第一字段，$2代表第二字段。
3）依据条件类型判断动作是否执行。如果条件符合，则执行动作，否则读入下一行数据。如果没有条件，则每行都执行动作。
4）读入下一行数据，重复执行以上步骤。
</code></pre>
<p>再举个例子，如果我想看看Sc用户的平均成绩呢:</p>
<p>例子2:</p>
<pre><code>[root@localhost ~]$ awk &#39;$2 ~ /AAA/ &#123;printf $6 &quot;\n&quot;&#125;&#39; student.txt
#如果第二字段中输入包含有“Sc”字符，则打印第六字段数据
85.66
</code></pre>
<p>这里要注意在awk中，使用“&#x2F;&#x2F;”包含的字符串，awk命令才会查找。也就是说字符串必须用“&#x2F;&#x2F;”包含，awk命令才能正确识别。</p>
<p>正则表达式<br>如果要想让awk 识别字符串，必须使用“&#x2F;&#x2F;”包含，例如:<br>例子1:</p>
<pre><code>[root@localhost ~]$ awk &#39;/Liming/ &#123;print&#125;’student.txt
#打印Liming的成绩
</code></pre>
<p>当使用df命令查看分区使用情况是，如果我只想查看真正的系统分区的使用状况，而不想查看光盘和临时分区的使用状况，则可以:</p>
<p>例子2:</p>
<pre><code>[root@localhost ~]$ df -h | awk &#39;/sda[O-9]/ &#123;printf $1 &quot;\t&quot; $5 &quot;\n&quot;&#125;’
#查询包含有sda数字的行，并打印第一字段和第五字段
</code></pre>
<h5 id="1-2-5-awk-内置变量"><a href="#1-2-5-awk-内置变量" class="headerlink" title="1.2.5 awk 内置变量"></a>1.2.5 awk 内置变量</h5><p>awk内置变量	作用</p>
<pre><code>$0	代表目前awk所读入的整行数据。我们已知awk是一行一行读入数据的，$0就代表当前读入行的整行数据。
$n	代表目前读入行的第n个字段。比如，$1表示第1个字段(列)，$2表示第2个字段(列)，如此类推
NF	当前行拥有的字段（列）总数。
NR	当前awk所处理的行，是总数据的第几行。
FS	用户定义分隔符。awk的默认分隔符是任何空格，如果想要使用其他分隔符（如“:”），就需要FS变量定义。
ARGC	命令行参数个数。
ARGV	命令行参数数组。
FNR	当前文件中的当前记录数（对输入文件起始为1）。
OFMT	数值的输出格式（默认为%.6g）。
OFS	输出字段的分隔符（默认为空格）。
ORS	输出记录分隔符（默认为换行符）。
RS	输入记录分隔符（默认为换行符）。
</code></pre>
<p>awk常用统计实例</p>
<pre><code>1、打印文件的第一列(域) ：
awk &#39;&#123;print $1&#125;&#39; filename

2、打印文件的前两列(域) ：
awk &#39;&#123;print $1,$2&#125;&#39; filename

3、打印完第一列，然后打印第二列 ： 
awk &#39;&#123;print $1 $2&#125;&#39; filename

4、打印文本文件的总行数 ： 
awk &#39;END&#123;print NR&#125;&#39; filename

5、打印文本第一行 ：
awk &#39;NR==1&#123;print&#125;&#39; filename

6、打印文本第二行第一列 ：
sed -n &quot;2, 1p&quot; filename | awk &#39;print $1&#39;



1. 获取第一列
ps -aux | grep watchdog | awk &#39;&#123;print $1&#125;&#39;

2. 获取第一列，第二列，第三列
ps -aux | grep watchdog | awk &#39;&#123;print $1, $2, $3&#125;&#39;

3. 获取第一行的第一列，第二列，第三列
ps -aux | grep watchdog | awk &#39;NR==1&#123;print $1, $2, $3&#125;&#39;

4. 获取行数NR
df -h | awk &#39;END&#123;print NR&#125;&#39;

5. 获取列数NF（这里是获取最后一行的列数，注意每行的列数可能是不同的）
ps -aux | grep watchdog | awk &#39;END&#123;print NF&#125;&#39;

6. 获取最后一列
ps -aux | grep watchdog | awk &#39;&#123;print $NF&#125;&#39;

7. 对文件进行操作
awk &#39;&#123;print $1&#125;&#39; fileName

8. 指定分隔符（这里以:分割）
ps -aux | grep watchdog |awk  -F&#39;:&#39; &#39;&#123;print $1&#125;&#39;

9. 超出范围不报错
ps -aux | grep watchdog | awk &#39;&#123;print $100&#125;&#39;

[root@localhost ~]$ cat /etc/passwd | grep &quot;/bin/bash&quot; | awk &#39;&#123;FS=&quot;:&quot;&#125; &#123;printf $1 &quot;\t&quot; $3 &quot;\n&quot;&#125;’
#查询可以登录的用户的用户名和UID
</code></pre>
<p>这里“:”分隔符生效了，可是第一行却没有起作用，原来我们忘记了“BEGIN”条件，那么再来试试;</p>
<pre><code>[root@localhost ~]$ cat /etc/passwd | grep &quot;/bin/bash&quot; | awk &#39;BEGIN &#123;FS=&quot;:&quot;&#125; &#123;printf $1 &quot;\t&quot; $3 &quot;\n&quot;&#125;’

&#123;printf $1 &quot;\t&quot; $3 &quot;\t 行号:” NR &quot;\t 字段数:&quot; NF &quot;\n&quot;&#125;’
#解释下awk命令
#开始执行&#123;分隔符是“:”&#125;&#123;输出第一字段和第三字段输出行号(NR值）字段数(NF值）&#125;
root     0      行号:1       字段数:7
user1   501     行号:2       字段数:7
</code></pre>
<p>如果我只想看看sshd这个伪用户的相关信息，则可以这样使用:</p>
<pre><code>[root@localhost ~]$ cat /etc/passwd | awk &#39;BEGIN &#123;FS=&quot;:&quot;&#125; $1==&quot;sshd&quot; &#123;printf $1 &quot;\t&quot; $3 &quot;\t 行号:&quot; NR &quot;\t 字段数:&quot; NF &quot;\n&quot;&#125;’
#可以看到sshd 伪用户的UID是74，是/etc/passwd_文件的第28行，此行有7个字段
</code></pre>
<h5 id="1-2-6-awk-流程控制"><a href="#1-2-6-awk-流程控制" class="headerlink" title="1.2.6 awk 流程控制"></a>1.2.6 awk 流程控制</h5><p>我们再来利用下student.txt文件做个练习，后面的使用比较复杂，我们再看看这个文件的内容:</p>
<pre><code>[root@localhost ~]$ cat student.txt
ID      Name    php   Linux  MySQL   Average
1       AAA      66         66       66           66
2       BBB      77         77       77           77
3       CCC      88         88       88           88
</code></pre>
<p>我们先来看看该如何在awk中定义变量与调用变量的值。假设我想统计PHP成绩的总分，那么就应该这样:</p>
<pre><code>[root@localhost ~]$ awk &#39;NR==2 &#123;php1=$3&#125;
NR==3 &#123;php2=$3&#125;
NR==4 &#123;php3=$3;totle=phpl+php2+php3;print &quot;totle php is &quot; totle&#125;’ student.txt
#统计PHIP成绩的总分
</code></pre>
<p>我们解释下这个命令。“NR&#x3D;&#x3D;2 {iphp1&#x3D;$3}” (条件是NR&#x3D;&#x3D;2，动作是php1&#x3D;$3） 这句话是指如果输入数据是第二行（第一行是标题行），就把第二行的第三字段的值赋予变量“php1”。<br>“NR&#x3D;&#x3D;3 {php2&#x3D;$3}” 这句话是指如果输入数据是第三行,就把第三行的第三字段的值赋予变量“php2”。“NR&#x3D;&#x3D;4 {php3&#x3D;$3;totle&#x3D;phpl+php2+php3;print “totle php is “ totle}”（“NR&#x3D;&#x3D;4”是条件，后面(中的都是动作)这句话是指如果输入数据是第四行﹐就把第四行的第三字段的值赋予变量”php3”;然后定义变量totle的值是“php1+php2+php3”;然后输出“totle php is”关键字，后面加变量totle的值。</p>
<p>在awk编程中，因为命令语句非常长，在输入格式时需要注意以下内容:</p>
<p>多个条件 {动作} 可以用空格分割，也可以用回车分割。</p>
<p>在一个动作中，如果需要执行多个命令，需要用 “;” 分割，或用回车分割。</p>
<p>在awk中，变量的赋值与调用都不需要加入“$”符。</p>
<p>条件中判断两个值是否相同，请使用 “&#x3D;&#x3D;”，以便和变量赋值进行区分。</p>
<p>在看看该如何实现流程控制，假设如果Linux成绩大于90，就是一个好男人(学PHP的表示压力很大!) :</p>
<pre><code>[root@localhost ~]$ awk &#39;&#123;if (NR&gt;=2) &#123;if ($4&gt;60) printf $2 &quot;is a good man!\n&quot;&#125;&#125;’ student.txt
#程序中有两个if判断，第一个判断行号大于2，第二个判断Linux成绩大于90分
Liming is a good man !
Sc is a good man !
</code></pre>
<p>其实在 awk中 if判断语句，完全可以直接利用awk自带的条件来取代，刚刚的脚本可以改写成这样:</p>
<pre><code>[root@localhost ~]$  awk ’NR&gt;=2 &#123;test=$4&#125;
test&gt;90 &#123;printf $2 &quot;is a good man! \n&quot;&#125;’ student.txt
#先判断行号如果大于2，就把第四字段赋予变量test
#在判断如果test的值大于90分，就打印好男人
Liming is a good man!
Sc is a good man!
</code></pre>
<h5 id="1-2-7-awk-函数"><a href="#1-2-7-awk-函数" class="headerlink" title="1.2.7 awk 函数"></a>1.2.7 awk 函数</h5><p>awk编程也允许在编程时使用函数，我们讲讲awk的自定义函数。awk函数的定义方法如下:</p>
<pre><code>function 函数名（参数列表）&#123;
    函数体
&#125;
</code></pre>
<p>我们定义一个简单的函数，使用函数来打印student.txt的学员姓名和平均成绩，应该这样来写函数：</p>
<pre><code>[root@localhost ~]$ awk &#39;function test(a,b) &#123; printf a &quot;\t&quot; b &quot;\n&quot;&#125;
#定义函数test，包含两个参数，函数体的内容是输出这两个参数的值
&#123; test($2,$6) &#125; &#39; student.txt
#调用函数test，并向两个参数传递值。
Name    Average
AAA      87.66
BBB      85.66
CCC      91.66
</code></pre>
<h5 id="1-2-8-awk-中调用脚本"><a href="#1-2-8-awk-中调用脚本" class="headerlink" title="1.2.8 awk 中调用脚本"></a>1.2.8 awk 中调用脚本</h5><p>对于小的单行程序来说，将脚本作为命令行自变量传递给awk是非常简单的，而对于多行程序就比较难处理。当程序是多行的时候，使用外部脚本是很适合的。首先在外部文件中写好脚本，然后可以使用awk的-f选项，使其读入脚本并且执行。<br>例如，我们可以先编写一个awk脚本:</p>
<pre><code>[root@localhost ~]$ vi pass.awk
BEGIN &#123;FS=&quot;:&quot;&#125;
&#123; print $1 &quot;\t&quot;  $3&#125;
</code></pre>
<p>然后可以使用“一f”选项来调用这个脚本:</p>
<pre><code>[root@localhost ~]$ awk -f pass.awk /etc/passwd
rooto
bin1
daemon2
…省略部分输出…
</code></pre>
<h4 id="1-3-sed-文本选取、替换、删除、新增的命令"><a href="#1-3-sed-文本选取、替换、删除、新增的命令" class="headerlink" title="1.3 sed 文本选取、替换、删除、新增的命令"></a>1.3 sed 文本选取、替换、删除、新增的命令</h4><p>sed主要是用来将数据进行选取、替换、删除、新增的命令。</p>
<p>语法:</p>
<pre><code>[root@localhost ~]$ sed [选项] ‘[动作]’ 文件名

选项:
-n:  一般sed命令会把所有数据都输出到屏幕，如果加入此选择，则只会把经过sed命令处理的行输出到屏幕。
-e:  允许对输入数据应用多条sed命令编辑。
-f 脚本文件名: 从sed脚本中读入sed操作。和awk命令的-f非常类似。
-r:  在sed中支持扩展正则表达式。
-i:  用sed的修改结果直接修改读取数据的文件，而不是由屏幕输出
</code></pre>
<p>动作:<br>    num a : 追加，在当前行后添加一行或多行。添加多行时，除最后一行外，每行末尾需要用“\”代表数据未完结。num表示第几行<br>    c : 行替换，用c后面的字符串替换原数据行，替换多行时，除最后一行外，每行末尾需用“”代表数据未完结。<br>    num i : 插入，在当期行前插入一行或多行。插入多行时，除最后一行外，每行末尾需要用“”代表数据未完结。num表示第几行<br>    d ; 删除，删除指定的行。<br>    p : 打印，输出指定的行。<br>    s : 字串替换，用一个字符串替换另外一个字符串。格式为“行范围s&#x2F;“旧字串&#x2F;新字串&#x2F;g”（和vim中的替换格式类似）。</p>
<p>对sed命令大家要注意，sed所做的修改并不会直接改变文件的内容（如果是用管道符接收的命令的输出，这种情况连文件都没有），而是把修改结果只显示到屏幕上，除非使用“-i”选项才会直接修改文件。</p>
<h5 id="1-3-1-提取行数据"><a href="#1-3-1-提取行数据" class="headerlink" title="1.3.1 提取行数据"></a>1.3.1 提取行数据</h5><p>我们举几个例子来看看sed命令到底是干嘛的。假设我想查看下student.txt的第二行，那么就可以利用“p”动作了:</p>
<pre><code>[root@localhost ~]$ sed  &#39;2p&#39; student.txt
ID      Name    php   Linux  MySQL   Average
1       AAA      66         66       66           66
2       BBB      77         77       77           77
3       CCC      88         88       88           88
</code></pre>
<p>指定输出某行，使用-n选项</p>
<pre><code>[root@localhost ~]$ sed -n  &#39;2p&#39; student.txt
1       AAA      66         66       66           66
</code></pre>
<h5 id="1-3-2-删除行数据"><a href="#1-3-2-删除行数据" class="headerlink" title="1.3.2 删除行数据"></a>1.3.2 删除行数据</h5><pre><code>[root@localhost ~]$ sed  &#39;2,4d&#39; student.txt
#删除第二行到第四行数据
</code></pre>
<h5 id="1-3-3-追加插入行数据"><a href="#1-3-3-追加插入行数据" class="headerlink" title="1.3.3 追加插入行数据"></a>1.3.3 追加插入行数据</h5><pre><code>[root@localhost ~]$ sed &#39;2a hello&#39; student.txt
#在第二行后加入 hello
</code></pre>
<p>“a”会在指定行后面追加入数据，如果想要在指定行前面插入数据，则需要使用“i”动作:</p>
<pre><code>[root@localhost ~]$ sed &#39;2i hello world&#39; student.txt
#在第二行前插入两行数据
</code></pre>
<p>如果是想追加或插入多行数据，除最后一行外，每行的末尾都要加入“\”代表数据未完结。再来看看“-n”选项的作用:</p>
<pre><code>[root@localhost ~]$ sed -n &#39;2i hello world&#39; student.txt
#只查看sed命令操作的数据
</code></pre>
<h5 id="1-3-4-替换行数据"><a href="#1-3-4-替换行数据" class="headerlink" title="1.3.4 替换行数据"></a>1.3.4 替换行数据</h5><p>“-n”只查看sed命令操作的数据，而不是查看所有数据。<br>再来看看如何实现行数据替换，假设AAA的成绩太好了，我实在是不想看到他的成绩刺激我，那就可以使用”c”动作:</p>
<pre><code>[root@localhost ~]$ cat student.txt | sed &#39;2c No such person&#39;
</code></pre>
<p>sed命令默认情况是不会修改文件内容的，如果我确定需要让 sed命令直接处理文件的内容，可以使用“-i”选项。不过要小心啊，这样非常容易误操作，在操作系统文件时请小心谨慎。可以使用<br>这样的命令:</p>
<pre><code>[root@localhost ~]$ sed -i &#39;2c No such person&#39; student.txt
</code></pre>
<h5 id="1-3-5-字符串替换"><a href="#1-3-5-字符串替换" class="headerlink" title="1.3.5 字符串替换"></a>1.3.5 字符串替换</h5><p>“c”动作是进行整行替换的，如果仅仅想替换行中的部分数据，就要使用“s”动作了。g 使得 sed 对文件中所有符合的字符串都被替换, 修改后内容会到标准输出，不会修改原文件。</p>
<pre><code>[root@localhost ~]$ sed &#39;s/旧字串/新字串/g&#39; 文件名
[root@localhost ~]$ sed &#39;行范围s/旧字串/新字串/g&#39; 文件名
</code></pre>
<p>替换的格式和vim非常类似，假设我觉得我自己的PHP成绩太低了，想作弊给他改高点，就可以这样来做:</p>
<pre><code>[root@localhost ~]$ sed &#39;3s/74/99/g&#39; student.txt
#在第三行中，把74换成99
</code></pre>
<p>这样看起来就比较爽了吧。如果我想把AAA老师的成绩注释掉，让他不再生效。可以这样做:</p>
<pre><code>[root@localhost ~]$ sed &#39;2s/^/#/g&#39; student.txt
#这里使用正则表达式，“^”代表行首
</code></pre>
<p>在sed中只能指定行范围，所以很遗憾我在他们两个的中间，不能只把他们两个注释掉，那么我们可以这样:</p>
<pre><code>[root@localhost ~]$ sed -e &#39;s/AAA//g ; s/BBB//g&#39; student.txt
#同时把“Liming”和“Tg”替换为空
</code></pre>
<p>“-e”选项可以同时执行多个sed动作，当然如果只是执行一个动作也可以使用“-e”选项，但是这时没有什么意义。还要注意，多个动作之间要用“;”号或回车分割，例如上一个命令也可以这样写:</p>
<pre><code>[root@localhost ~]$ sed -e &#39;s/Liming//g
&gt;s/Tg//g&#39;’ student.txt
</code></pre>
<h3 id="2-字符处理命令"><a href="#2-字符处理命令" class="headerlink" title="2 字符处理命令"></a>2 字符处理命令</h3><h4 id="2-1-sort-排序命令"><a href="#2-1-sort-排序命令" class="headerlink" title="2.1 sort 排序命令"></a>2.1 sort 排序命令</h4><pre><code>[root@localhost~]$ sort [选项] 文件名
选项:

-f: 忽略大小写
-b: 忽略每行前面的空白部分
-n: 以数值型进行排序，默认使用字符串型排序
-r: 反向排序
-u: 删除重复行。就是uniq命令
-t: 指定分隔符，默认是分隔符是制表符
-k n[,m]: ―按照指定的字段范围排序。从第n字段开始，m字段结束（默认到行尾）
</code></pre>
<p>案例：</p>
<p>sort命令默认是用每行开头第一个字符来进行排序的，比如:</p>
<pre><code>[root@localhost~]$ sort /etc/passwd
#排序用户信息文件
</code></pre>
<p>如果想要反向排序，请使用“-r”选项:</p>
<pre><code>[root@localhost~]$ sort -r/etc/passwd
#反向排序
</code></pre>
<p>如果想要指定排序的字段，需要使用“-t”选项指定分隔符，并使用“-k”选项指定字段号。加入我想要按照UID字段排序&#x2F;etc&#x2F;passwd文件:</p>
<pre><code>[root@localhost~]$ sort -t &quot;:&quot; -k 3,3 /etc/passwd
#指定分隔符是“:”，用第三字段开头，第三字段结尾排序，就是只用第三字段排序
</code></pre>
<p>因为sort默认是按照字符排序，前面用户的UID的第一个字符都是1，所以这么排序。要想按照数字排序，请使用“-n”选项:</p>
<pre><code>[root@localhost~]$ sort -n -t &quot;:&quot; -k 3,3 /etc/passwd
</code></pre>
<p>当然“-k”选项可以直接使用“-k 3”，代表从第三字段到行尾都排序（第一个字符先排序，如果一致，第二个字符再排序，知道行尾）。</p>
<h4 id="2-2-uniq-取消重复行"><a href="#2-2-uniq-取消重复行" class="headerlink" title="2.2 uniq 取消重复行"></a>2.2 uniq 取消重复行</h4><pre><code>[root@localhost~]$ uniq [选项] 文件名
选项：
    -i：忽略大小写
</code></pre>
<h4 id="2-3-wc-统计命令"><a href="#2-3-wc-统计命令" class="headerlink" title="2.3 wc 统计命令"></a>2.3 wc 统计命令</h4><pre><code>[root@localhost~]$ wc [选项] 文件名
选项：
    -l：只统计行数
    -w：只统计单词数
    -m：只统计字符数
</code></pre>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://sunk15.top">sunk</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://sunk15.top/2023/02/07/linux/shell%E6%95%99%E7%A8%8B/">http://sunk15.top/2023/02/07/linux/shell%E6%95%99%E7%A8%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://sunk15.top" target="_blank">DDUP</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/LINUX/">LINUX</a></div><div class="post_share"><div class="social-share" data-image="https://s1.ax1x.com/2023/02/08/pSRUin0.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/02/07/linux/shell%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/" title="shell命令记录"><img class="cover" src="https://s1.ax1x.com/2023/02/08/pSRUin0.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">shell命令记录</div></div></a></div><div class="next-post pull-right"><a href="/2023/02/07/%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%AF%86%E9%92%A5%E5%8F%8A%E8%AF%81%E4%B9%A6%E7%9B%B8%E5%85%B3/" title="密码学"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">密码学</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://s1.ax1x.com/2023/02/08/pS2XoY6.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">sunk</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">18</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/xxxxx" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:xxxxxx@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">近水知鱼性，近山识鸟音。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFshell%EF%BC%9F"><span class="toc-text">一、什么是shell？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81shell%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">二、shell的分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81shell%E5%8F%98%E9%87%8F"><span class="toc-text">三、shell变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%8F%98%E9%87%8F%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99%EF%BC%9A"><span class="toc-text">1. 变量的命名规则：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%86%E7%B1%BB%EF%BC%9A"><span class="toc-text">2. 变量的分类：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F%EF%BC%9A"><span class="toc-text">2.1 用户自定义变量：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89"><span class="toc-text">2.1.1 变量定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2-%E5%8F%98%E9%87%8F%E8%B0%83%E7%94%A8"><span class="toc-text">2.1.2 变量调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-3-%E5%8F%98%E9%87%8F%E6%9F%A5%E7%9C%8B"><span class="toc-text">2.1.3 变量查看</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-4-%E5%8F%98%E9%87%8F%E5%88%A0%E9%99%A4"><span class="toc-text">2.1.4 变量删除</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%EF%BC%9A"><span class="toc-text">2.2 环境变量：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E8%AE%BE%E7%BD%AE"><span class="toc-text">2.2.1 环境变量设置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E6%9F%A5%E8%AF%A2%E5%92%8C%E5%88%A0%E9%99%A4"><span class="toc-text">2.2.2 环境变量查询和删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-3-%E7%B3%BB%E7%BB%9F%E9%BB%98%E8%AE%A4%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-text">2.2.3 系统默认环境变量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E4%BD%8D%E7%BD%AE%E5%8F%82%E6%95%B0%E5%8F%98%E9%87%8F%EF%BC%9A"><span class="toc-text">2.3 位置参数变量：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E9%A2%84%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F%EF%BC%9A"><span class="toc-text">2.4 预定义变量：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8F%AA%E8%AF%BB%E5%8F%98%E9%87%8F%EF%BC%9A"><span class="toc-text">3. 只读变量：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%8E%A5%E5%8F%97%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5%EF%BC%9A"><span class="toc-text">4. 接受键盘输入：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81shell-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">四、shell 运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%AE%97%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">1. 算数运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">2. 关系运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">3. 逻辑运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">4. 字符串运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%96%87%E4%BB%B6%E6%B5%8B%E8%AF%95%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-text">5. 文件测试运算符（重点）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-text">五、流程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-if%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD"><span class="toc-text">1. if条件判断</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E5%8D%95%E5%88%86%E6%94%AFif%E6%9D%A1%E4%BB%B6"><span class="toc-text">1.1 单分支if条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E5%8F%8C%E5%88%86%E6%94%AFif%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5"><span class="toc-text">1.2 双分支if条件语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E5%A4%9A%E5%88%86%E6%94%AFif%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5"><span class="toc-text">1.3 多分支if条件语句</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A4%9A%E5%88%86%E6%94%AFcase%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5"><span class="toc-text">2. 多分支case条件语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-for%E5%BE%AA%E7%8E%AF"><span class="toc-text">3. for循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-while%E5%BE%AA%E7%8E%AF"><span class="toc-text">4. while循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-until%E5%BE%AA%E7%8E%AF"><span class="toc-text">5. until循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%87%BD%E6%95%B0"><span class="toc-text">6. 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E7%89%B9%E6%AE%8A%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5"><span class="toc-text">7. 特殊流程控制语句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-exit%E8%AF%AD%E5%8F%A5"><span class="toc-text">7.1 exit语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-break%E8%AF%AD%E5%8F%A5"><span class="toc-text">7.2 break语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-continue%E8%AF%AD%E5%8F%A5"><span class="toc-text">7.3 continue语句</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%AD%97%E7%AC%A6%E6%88%AA%E5%8F%96%E3%80%81%E6%9B%BF%E6%8D%A2%E5%92%8C%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4"><span class="toc-text">六、字符截取、替换和处理命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AD%97%E7%AC%A6%E6%88%AA%E5%8F%96%E3%80%81%E6%9B%BF%E6%8D%A2%E5%91%BD%E4%BB%A4"><span class="toc-text">1 字符截取、替换命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-cut-%E5%88%97%E6%8F%90%E5%8F%96%E5%91%BD%E4%BB%A4"><span class="toc-text">1.1 cut 列提取命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-awk-%E7%BC%96%E7%A8%8B"><span class="toc-text">1.2 awk 编程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-1-awk-%E6%A6%82%E8%BF%B0"><span class="toc-text">1.2.1 awk 概述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-2-printf-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA"><span class="toc-text">1.2.2 printf 格式化输出</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-3-awk-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-text">1.2.3 awk 基本使用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-4-awk-%E7%9A%84%E6%9D%A1%E4%BB%B6"><span class="toc-text">1.2.4 awk 的条件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-5-awk-%E5%86%85%E7%BD%AE%E5%8F%98%E9%87%8F"><span class="toc-text">1.2.5 awk 内置变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-6-awk-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-text">1.2.6 awk 流程控制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-7-awk-%E5%87%BD%E6%95%B0"><span class="toc-text">1.2.7 awk 函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-8-awk-%E4%B8%AD%E8%B0%83%E7%94%A8%E8%84%9A%E6%9C%AC"><span class="toc-text">1.2.8 awk 中调用脚本</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-sed-%E6%96%87%E6%9C%AC%E9%80%89%E5%8F%96%E3%80%81%E6%9B%BF%E6%8D%A2%E3%80%81%E5%88%A0%E9%99%A4%E3%80%81%E6%96%B0%E5%A2%9E%E7%9A%84%E5%91%BD%E4%BB%A4"><span class="toc-text">1.3 sed 文本选取、替换、删除、新增的命令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-3-1-%E6%8F%90%E5%8F%96%E8%A1%8C%E6%95%B0%E6%8D%AE"><span class="toc-text">1.3.1 提取行数据</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-3-2-%E5%88%A0%E9%99%A4%E8%A1%8C%E6%95%B0%E6%8D%AE"><span class="toc-text">1.3.2 删除行数据</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-3-3-%E8%BF%BD%E5%8A%A0%E6%8F%92%E5%85%A5%E8%A1%8C%E6%95%B0%E6%8D%AE"><span class="toc-text">1.3.3 追加插入行数据</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-3-4-%E6%9B%BF%E6%8D%A2%E8%A1%8C%E6%95%B0%E6%8D%AE"><span class="toc-text">1.3.4 替换行数据</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-3-5-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9B%BF%E6%8D%A2"><span class="toc-text">1.3.5 字符串替换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AD%97%E7%AC%A6%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4"><span class="toc-text">2 字符处理命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-sort-%E6%8E%92%E5%BA%8F%E5%91%BD%E4%BB%A4"><span class="toc-text">2.1 sort 排序命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-uniq-%E5%8F%96%E6%B6%88%E9%87%8D%E5%A4%8D%E8%A1%8C"><span class="toc-text">2.2 uniq 取消重复行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-wc-%E7%BB%9F%E8%AE%A1%E5%91%BD%E4%BB%A4"><span class="toc-text">2.3 wc 统计命令</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By sunk</div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://butterfly.js.org/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><div class="js-pjax"></div><script src="https://cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>